{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\vtrav\\\\Desktop\\\\my-new-app\\\\ethereal-violet-orb\\\\src\\\\EtherealOrb.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EtherealOrb = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const particles = useRef([]);\n  const whispers = useRef([]);\n  const orbRadius = 100;\n  const [isSplit, setIsSplit] = useState(false);\n  const [splitProgress, setSplitProgress] = useState(0);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    let width, height;\n\n    // ... (keep all your existing functions)\n\n    function drawOrb(t) {\n      if (isSplit) {\n        drawSplitOrb(t);\n      } else {\n        drawWholeOrb(t);\n      }\n    }\n    function drawWholeOrb(t) {\n      // ... (your existing drawOrb function)\n    }\n    function drawSplitOrb(t) {\n      ctx.save();\n      ctx.translate(width / 2, height / 2);\n      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\n      gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\n      gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\n      gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\n      gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\n      const leftX = -width / 2 * splitProgress;\n      const rightX = width / 2 * splitProgress;\n\n      // Left half\n      ctx.beginPath();\n      for (let i = 90; i <= 270; i += 5) {\n        const angle = i * Math.PI / 180;\n        const noise = Math.sin(i * 0.05 + t) * 4;\n        const r = orbRadius + noise;\n        const x = Math.cos(angle) * r + leftX;\n        const y = Math.sin(angle) * r;\n        if (i === 90) ctx.moveTo(x, y);else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.6;\n      ctx.fill();\n\n      // Right half\n      ctx.beginPath();\n      for (let i = 270; i <= 450; i += 5) {\n        const angle = i * Math.PI / 180;\n        const noise = Math.sin(i * 0.05 + t) * 4;\n        const r = orbRadius + noise;\n        const x = Math.cos(angle) * r + rightX;\n        const y = Math.sin(angle) * r;\n        if (i === 270) ctx.moveTo(x, y);else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.6;\n      ctx.fill();\n      ctx.restore();\n    }\n    function animate(time) {\n      ctx.clearRect(0, 0, width, height);\n      drawBackground();\n      drawOrb(time / 1000);\n      updateParticles();\n      drawParticles();\n      updateWhispers();\n      drawWhispers();\n      if (isSplit && splitProgress < 1) {\n        setSplitProgress(prev => Math.min(prev + 0.02, 1));\n      } else if (!isSplit && splitProgress > 0) {\n        setSplitProgress(prev => Math.max(prev - 0.02, 0));\n      }\n      requestAnimationFrame(animate);\n    }\n    function handleClick(event) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const dx = x - width / 2;\n      const dy = y - height / 2;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance < orbRadius) {\n        setIsSplit(prev => !prev);\n      }\n    }\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('click', handleClick);\n    requestAnimationFrame(animate);\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      canvas.removeEventListener('click', handleClick);\n    };\n  }, [isSplit]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      width: '100%',\n      height: '100%',\n      display: 'block'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 123,\n    columnNumber: 10\n  }, this);\n};\n_s(EtherealOrb, \"4n0x+prIL8KiH69qSBHsP6f82gc=\");\n_c = EtherealOrb;\nexport default EtherealOrb;\nvar _c;\n$RefreshReg$(_c, \"EtherealOrb\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","EtherealOrb","_s","canvasRef","particles","whispers","orbRadius","isSplit","setIsSplit","splitProgress","setSplitProgress","canvas","current","ctx","getContext","width","height","drawOrb","t","drawSplitOrb","drawWholeOrb","save","translate","gradient","createRadialGradient","addColorStop","leftX","rightX","beginPath","i","angle","Math","PI","noise","sin","r","x","cos","y","moveTo","lineTo","closePath","fillStyle","globalAlpha","fill","restore","animate","time","clearRect","drawBackground","updateParticles","drawParticles","updateWhispers","drawWhispers","prev","min","max","requestAnimationFrame","handleClick","event","clientX","clientY","dx","dy","distance","sqrt","resizeCanvas","window","addEventListener","handleMouseMove","removeEventListener","ref","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/vtrav/Desktop/my-new-app/ethereal-violet-orb/src/EtherealOrb.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport './App.css';\r\n\r\nconst EtherealOrb = () => {\r\n  const canvasRef = useRef(null);\r\n  const particles = useRef([]);\r\n  const whispers = useRef([]);\r\n  const orbRadius = 100;\r\n  const [isSplit, setIsSplit] = useState(false);\r\n  const [splitProgress, setSplitProgress] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    let width, height;\r\n\r\n    // ... (keep all your existing functions)\r\n\r\n    function drawOrb(t) {\r\n      if (isSplit) {\r\n        drawSplitOrb(t);\r\n      } else {\r\n        drawWholeOrb(t);\r\n      }\r\n    }\r\n\r\n    function drawWholeOrb(t) {\r\n      // ... (your existing drawOrb function)\r\n    }\r\n\r\n    function drawSplitOrb(t) {\r\n      ctx.save();\r\n      ctx.translate(width / 2, height / 2);\r\n\r\n      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\r\n      gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\r\n      gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\r\n      gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\r\n      gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\r\n\r\n      const leftX = -width / 2 * splitProgress;\r\n      const rightX = width / 2 * splitProgress;\r\n\r\n      // Left half\r\n      ctx.beginPath();\r\n      for (let i = 90; i <= 270; i += 5) {\r\n        const angle = (i * Math.PI) / 180;\r\n        const noise = Math.sin(i * 0.05 + t) * 4;\r\n        const r = orbRadius + noise;\r\n        const x = Math.cos(angle) * r + leftX;\r\n        const y = Math.sin(angle) * r;\r\n        if (i === 90) ctx.moveTo(x, y);\r\n        else ctx.lineTo(x, y);\r\n      }\r\n      ctx.closePath();\r\n      ctx.fillStyle = gradient;\r\n      ctx.globalAlpha = 0.6;\r\n      ctx.fill();\r\n\r\n      // Right half\r\n      ctx.beginPath();\r\n      for (let i = 270; i <= 450; i += 5) {\r\n        const angle = (i * Math.PI) / 180;\r\n        const noise = Math.sin(i * 0.05 + t) * 4;\r\n        const r = orbRadius + noise;\r\n        const x = Math.cos(angle) * r + rightX;\r\n        const y = Math.sin(angle) * r;\r\n        if (i === 270) ctx.moveTo(x, y);\r\n        else ctx.lineTo(x, y);\r\n      }\r\n      ctx.closePath();\r\n      ctx.fillStyle = gradient;\r\n      ctx.globalAlpha = 0.6;\r\n      ctx.fill();\r\n\r\n      ctx.restore();\r\n    }\r\n\r\n    function animate(time) {\r\n      ctx.clearRect(0, 0, width, height);\r\n      drawBackground();\r\n      drawOrb(time / 1000);\r\n      updateParticles();\r\n      drawParticles();\r\n      updateWhispers();\r\n      drawWhispers();\r\n\r\n      if (isSplit && splitProgress < 1) {\r\n        setSplitProgress(prev => Math.min(prev + 0.02, 1));\r\n      } else if (!isSplit && splitProgress > 0) {\r\n        setSplitProgress(prev => Math.max(prev - 0.02, 0));\r\n      }\r\n\r\n      requestAnimationFrame(animate);\r\n    }\r\n\r\n    function handleClick(event) {\r\n      const x = event.clientX;\r\n      const y = event.clientY;\r\n      const dx = x - width / 2;\r\n      const dy = y - height / 2;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance < orbRadius) {\r\n        setIsSplit(prev => !prev);\r\n      }\r\n    }\r\n\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n    canvas.addEventListener('mousemove', handleMouseMove);\r\n    canvas.addEventListener('click', handleClick);\r\n\r\n    requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas);\r\n      canvas.removeEventListener('mousemove', handleMouseMove);\r\n      canvas.removeEventListener('click', handleClick);\r\n    };\r\n  }, [isSplit]);\r\n\r\n  return <canvas ref={canvasRef} style={{ width: '100%', height: '100%', display: 'block' }} />;\r\n};\r\n\r\nexport default EtherealOrb;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}