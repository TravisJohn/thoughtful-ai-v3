{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\vtrav\\\\Desktop\\\\my-new-app\\\\ethereal-violet-orb\\\\src\\\\EtherealOrb.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport './App.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EtherealOrb = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const particles = useRef([]);\n  const whispers = useRef([]);\n  const orbRadius = 100;\n  const [isSplit, setIsSplit] = useState(false);\n  const [splitProgress, setSplitProgress] = useState(0);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    let width, height;\n    const greetings = ['Hey...', 'Welcome...', 'Hello...', 'Hi there...', 'Greetings...'];\n    function resizeCanvas() {\n      width = window.innerWidth;\n      height = window.innerHeight;\n      canvas.width = width;\n      canvas.height = height;\n    }\n    function createGradient() {\n      const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height) / 2);\n      gradient.addColorStop(0, '#ffffff');\n      gradient.addColorStop(0.7, '#f0f0f0');\n      gradient.addColorStop(1, '#e0e0e0');\n      return gradient;\n    }\n    function drawBackground() {\n      ctx.fillStyle = createGradient();\n      ctx.fillRect(0, 0, width, height);\n    }\n    function drawOrb(t) {\n      if (splitProgress > 0) {\n        drawSplitOrb(t);\n      } else {\n        drawWholeOrb(t);\n      }\n    }\n    function drawWholeOrb(t) {\n      ctx.save();\n      ctx.translate(width / 2, height / 2);\n      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\n      gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\n      gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\n      gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\n      gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\n      ctx.beginPath();\n      for (let i = 0; i < 360; i += 5) {\n        const angle = i * Math.PI / 180;\n        const noise = Math.sin(i * 0.05 + t) * 4;\n        const r = orbRadius + noise;\n        const x = Math.cos(angle) * r;\n        const y = Math.sin(angle) * r;\n        if (i === 0) ctx.moveTo(x, y);else ctx.lineTo(x, y);\n      }\n      ctx.closePath();\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.6;\n      ctx.fill();\n      ctx.restore();\n    }\n    function drawSplitOrb(t) {\n      ctx.save();\n      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\n      gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\n      gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\n      gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\n      gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\n      const bubbleWidth = width * 0.3;\n      const bubbleHeight = height * 0.2;\n      const cornerRadius = 20;\n\n      // Left orb/bubble\n      const leftX = lerp(0, -width / 2 + bubbleWidth / 2 + 20, splitProgress);\n      const leftY = lerp(0, -height / 2 + bubbleHeight / 2 + 20, splitProgress);\n      drawMorphingShape(leftX, leftY, t, gradient, splitProgress, true);\n\n      // Right orb/bubble\n      const rightX = lerp(0, width / 2 - bubbleWidth / 2 - 20, splitProgress);\n      const rightY = lerp(0, -height / 2 + bubbleHeight / 2 + 20, splitProgress);\n      drawMorphingShape(rightX, rightY, t, gradient, splitProgress, false);\n      ctx.restore();\n    }\n    function drawMorphingShape(x, y, t, gradient, progress, isLeft) {\n      ctx.save();\n      ctx.translate(x, y);\n      const bubbleWidth = width * 0.3;\n      const bubbleHeight = height * 0.2;\n      const cornerRadius = 20;\n      ctx.beginPath();\n      if (progress < 0.5) {\n        // Draw half of the orb\n        const startAngle = isLeft ? Math.PI / 2 : -Math.PI / 2;\n        const endAngle = isLeft ? 3 * Math.PI / 2 : Math.PI / 2;\n        for (let i = startAngle; i <= endAngle; i += 0.1) {\n          const noise = Math.sin(i * 10 + t) * 4;\n          const r = orbRadius + noise;\n          const x = Math.cos(i) * r;\n          const y = Math.sin(i) * r;\n          if (i === startAngle) ctx.moveTo(x, y);else ctx.lineTo(x, y);\n        }\n      } else {\n        // Draw rounded rectangle\n        const morphProgress = (progress - 0.5) * 2;\n        const width = lerp(orbRadius * 2, bubbleWidth, morphProgress);\n        const height = lerp(orbRadius * 2, bubbleHeight, morphProgress);\n        const radius = lerp(orbRadius, cornerRadius, morphProgress);\n        ctx.moveTo(-width / 2 + radius, -height / 2);\n        ctx.arcTo(width / 2, -height / 2, width / 2, height / 2, radius);\n        ctx.arcTo(width / 2, height / 2, -width / 2, height / 2, radius);\n        ctx.arcTo(-width / 2, height / 2, -width / 2, -height / 2, radius);\n        ctx.arcTo(-width / 2, -height / 2, width / 2, -height / 2, radius);\n      }\n      ctx.closePath();\n      ctx.fillStyle = gradient;\n      ctx.globalAlpha = 0.6;\n      ctx.fill();\n      ctx.restore();\n    }\n    function lerp(start, end, t) {\n      return start * (1 - t) + end * t;\n    }\n    function updateParticles() {\n      particles.current = particles.current.filter(p => p.opacity > 0 && p.size > 0);\n      particles.current.forEach(p => {\n        p.x += p.vx;\n        p.y += p.vy;\n        p.opacity -= 0.01;\n        p.size = Math.max(0, p.size - 0.05);\n      });\n    }\n    function drawParticles() {\n      particles.current.forEach(p => {\n        if (p.size > 0) {\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n          ctx.fillStyle = `rgba(126, 34, 206, ${p.opacity})`;\n          ctx.fill();\n        }\n      });\n    }\n    function updateWhispers() {\n      const now = Date.now();\n      whispers.current = whispers.current.filter(w => w.opacity > 0 || now - w.createdAt < 12000);\n      whispers.current.forEach(w => {\n        const age = now - w.createdAt;\n        if (age < 5000) {\n          w.opacity = age / 5000; // Fade in over 5 seconds\n        } else if (age > 7000) {\n          w.opacity = Math.max(0, 0.2 - (age - 7000) / 5000); // Fade out after 7 seconds\n        } else {\n          w.opacity = 0.2; // Full opacity\n        }\n      });\n    }\n    function drawWhispers() {\n      ctx.font = 'bold 24px \"Orbitron\"';\n      ctx.textAlign = 'center';\n      whispers.current.forEach(w => {\n        ctx.fillStyle = `rgba(0, 0, 0, ${w.opacity})`;\n        ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';\n        ctx.shadowOffsetX = 2;\n        ctx.shadowOffsetY = 2;\n        ctx.shadowBlur = 3;\n        ctx.fillText(w.text, w.x, w.y);\n        ctx.shadowColor = 'transparent';\n      });\n    }\n    function animate(time) {\n      ctx.clearRect(0, 0, width, height);\n      drawBackground();\n      drawOrb(time / 1000);\n      updateParticles();\n      drawParticles();\n      updateWhispers();\n      drawWhispers();\n      if (isSplit && splitProgress < 1) {\n        setSplitProgress(prev => Math.min(prev + 0.005, 1)); // Even slower animation\n      } else if (!isSplit && splitProgress > 0) {\n        setSplitProgress(prev => Math.max(prev - 0.005, 0)); // Even slower animation\n      }\n      requestAnimationFrame(animate);\n    }\n    function handleMouseMove(event) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const dx = x - width / 2;\n      const dy = y - height / 2;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance < orbRadius) {\n        if (Math.random() < 0.02) {\n          whispers.current.push({\n            text: greetings[Math.floor(Math.random() * greetings.length)],\n            x: width / 2 + Math.random() * 200 - 100,\n            y: height / 2 + Math.random() * 200 - 100,\n            opacity: 0,\n            createdAt: Date.now()\n          });\n        }\n      }\n      if (Math.random() < 0.3) {\n        const angle = Math.random() * 2 * Math.PI;\n        const speed = 0.5 + Math.random() * 1;\n        particles.current.push({\n          x,\n          y,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          opacity: 0.5,\n          size: 1 + Math.random() * 2\n        });\n      }\n    }\n    function handleClick(event) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const dx = x - width / 2;\n      const dy = y - height / 2;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      if (distance < orbRadius) {\n        setIsSplit(prev => !prev);\n      }\n    }\n    resizeCanvas();\n    window.addEventListener('resize', resizeCanvas);\n    canvas.addEventListener('mousemove', handleMouseMove);\n    canvas.addEventListener('click', handleClick);\n    requestAnimationFrame(animate);\n    return () => {\n      window.removeEventListener('resize', resizeCanvas);\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      canvas.removeEventListener('click', handleClick);\n    };\n  }, [isSplit, splitProgress]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      width: '100%',\n      height: '100%',\n      display: 'block'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 290,\n    columnNumber: 10\n  }, this);\n};\n_s(EtherealOrb, \"4n0x+prIL8KiH69qSBHsP6f82gc=\");\n_c = EtherealOrb;\nexport default EtherealOrb;\nvar _c;\n$RefreshReg$(_c, \"EtherealOrb\");","map":{"version":3,"names":["React","useState","useEffect","useRef","jsxDEV","_jsxDEV","EtherealOrb","_s","canvasRef","particles","whispers","orbRadius","isSplit","setIsSplit","splitProgress","setSplitProgress","canvas","current","ctx","getContext","width","height","greetings","resizeCanvas","window","innerWidth","innerHeight","createGradient","gradient","createRadialGradient","Math","max","addColorStop","drawBackground","fillStyle","fillRect","drawOrb","t","drawSplitOrb","drawWholeOrb","save","translate","beginPath","i","angle","PI","noise","sin","r","x","cos","y","moveTo","lineTo","closePath","globalAlpha","fill","restore","bubbleWidth","bubbleHeight","cornerRadius","leftX","lerp","leftY","drawMorphingShape","rightX","rightY","progress","isLeft","startAngle","endAngle","morphProgress","radius","arcTo","start","end","updateParticles","filter","p","opacity","size","forEach","vx","vy","drawParticles","arc","updateWhispers","now","Date","w","createdAt","age","drawWhispers","font","textAlign","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","fillText","text","animate","time","clearRect","prev","min","requestAnimationFrame","handleMouseMove","event","clientX","clientY","dx","dy","distance","sqrt","random","push","floor","length","speed","handleClick","addEventListener","removeEventListener","ref","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/vtrav/Desktop/my-new-app/ethereal-violet-orb/src/EtherealOrb.js"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport './App.css';\r\n\r\nconst EtherealOrb = () => {\r\n  const canvasRef = useRef(null);\r\n  const particles = useRef([]);\r\n  const whispers = useRef([]);\r\n  const orbRadius = 100;\r\n  const [isSplit, setIsSplit] = useState(false);\r\n  const [splitProgress, setSplitProgress] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    let width, height;\r\n\r\n    const greetings = [\r\n      'Hey...',\r\n      'Welcome...',\r\n      'Hello...',\r\n      'Hi there...',\r\n      'Greetings...',\r\n    ];\r\n\r\n    function resizeCanvas() {\r\n      width = window.innerWidth;\r\n      height = window.innerHeight;\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n    }\r\n\r\n    function createGradient() {\r\n      const gradient = ctx.createRadialGradient(\r\n        width / 2,\r\n        height / 2,\r\n        0,\r\n        width / 2,\r\n        height / 2,\r\n        Math.max(width, height) / 2\r\n      );\r\n      gradient.addColorStop(0, '#ffffff');\r\n      gradient.addColorStop(0.7, '#f0f0f0');\r\n      gradient.addColorStop(1, '#e0e0e0');\r\n      return gradient;\r\n    }\r\n\r\n    function drawBackground() {\r\n      ctx.fillStyle = createGradient();\r\n      ctx.fillRect(0, 0, width, height);\r\n    }\r\n\r\n    function drawOrb(t) {\r\n        if (splitProgress > 0) {\r\n          drawSplitOrb(t);\r\n        } else {\r\n          drawWholeOrb(t);\r\n        }\r\n      }\r\n\r\n      function drawWholeOrb(t) {\r\n        ctx.save();\r\n        ctx.translate(width / 2, height / 2);\r\n      \r\n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\r\n        gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\r\n        gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\r\n        gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\r\n        gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\r\n      \r\n        ctx.beginPath();\r\n        for (let i = 0; i < 360; i += 5) {\r\n          const angle = (i * Math.PI) / 180;\r\n          const noise = Math.sin(i * 0.05 + t) * 4;\r\n          const r = orbRadius + noise;\r\n          const x = Math.cos(angle) * r;\r\n          const y = Math.sin(angle) * r;\r\n          if (i === 0) ctx.moveTo(x, y);\r\n          else ctx.lineTo(x, y);\r\n        }\r\n        ctx.closePath();\r\n      \r\n        ctx.fillStyle = gradient;\r\n        ctx.globalAlpha = 0.6;\r\n        ctx.fill();\r\n        ctx.restore();\r\n      }\r\n\r\n      function drawSplitOrb(t) {\r\n        ctx.save();\r\n      \r\n        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, orbRadius);\r\n        gradient.addColorStop(0, 'rgba(147, 51, 234, 0.4)');\r\n        gradient.addColorStop(0.4, 'rgba(126, 34, 206, 0.3)');\r\n        gradient.addColorStop(0.8, 'rgba(107, 33, 168, 0.2)');\r\n        gradient.addColorStop(1, 'rgba(88, 28, 135, 0.1)');\r\n      \r\n        const bubbleWidth = width * 0.3;\r\n        const bubbleHeight = height * 0.2;\r\n        const cornerRadius = 20;\r\n      \r\n        // Left orb/bubble\r\n        const leftX = lerp(0, -width / 2 + bubbleWidth / 2 + 20, splitProgress);\r\n        const leftY = lerp(0, -height / 2 + bubbleHeight / 2 + 20, splitProgress);\r\n        drawMorphingShape(leftX, leftY, t, gradient, splitProgress, true);\r\n      \r\n        // Right orb/bubble\r\n        const rightX = lerp(0, width / 2 - bubbleWidth / 2 - 20, splitProgress);\r\n        const rightY = lerp(0, -height / 2 + bubbleHeight / 2 + 20, splitProgress);\r\n        drawMorphingShape(rightX, rightY, t, gradient, splitProgress, false);\r\n      \r\n        ctx.restore();\r\n      }\r\n\r\n      function drawMorphingShape(x, y, t, gradient, progress, isLeft) {\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n      \r\n        const bubbleWidth = width * 0.3;\r\n        const bubbleHeight = height * 0.2;\r\n        const cornerRadius = 20;\r\n      \r\n        ctx.beginPath();\r\n      \r\n        if (progress < 0.5) {\r\n          // Draw half of the orb\r\n          const startAngle = isLeft ? Math.PI / 2 : -Math.PI / 2;\r\n          const endAngle = isLeft ? 3 * Math.PI / 2 : Math.PI / 2;\r\n          for (let i = startAngle; i <= endAngle; i += 0.1) {\r\n            const noise = Math.sin(i * 10 + t) * 4;\r\n            const r = orbRadius + noise;\r\n            const x = Math.cos(i) * r;\r\n            const y = Math.sin(i) * r;\r\n            if (i === startAngle) ctx.moveTo(x, y);\r\n            else ctx.lineTo(x, y);\r\n          }\r\n        } else {\r\n          // Draw rounded rectangle\r\n          const morphProgress = (progress - 0.5) * 2;\r\n          const width = lerp(orbRadius * 2, bubbleWidth, morphProgress);\r\n          const height = lerp(orbRadius * 2, bubbleHeight, morphProgress);\r\n          const radius = lerp(orbRadius, cornerRadius, morphProgress);\r\n      \r\n          ctx.moveTo(-width / 2 + radius, -height / 2);\r\n          ctx.arcTo(width / 2, -height / 2, width / 2, height / 2, radius);\r\n          ctx.arcTo(width / 2, height / 2, -width / 2, height / 2, radius);\r\n          ctx.arcTo(-width / 2, height / 2, -width / 2, -height / 2, radius);\r\n          ctx.arcTo(-width / 2, -height / 2, width / 2, -height / 2, radius);\r\n        }\r\n      \r\n        ctx.closePath();\r\n        ctx.fillStyle = gradient;\r\n        ctx.globalAlpha = 0.6;\r\n        ctx.fill();\r\n      \r\n        ctx.restore();\r\n      }\r\n      \r\n      function lerp(start, end, t) {\r\n        return start * (1 - t) + end * t;\r\n      }\r\n\r\n    function updateParticles() {\r\n      particles.current = particles.current.filter((p) => p.opacity > 0 && p.size > 0);\r\n      particles.current.forEach((p) => {\r\n        p.x += p.vx;\r\n        p.y += p.vy;\r\n        p.opacity -= 0.01;\r\n        p.size = Math.max(0, p.size - 0.05);\r\n      });\r\n    }\r\n\r\n    function drawParticles() {\r\n      particles.current.forEach((p) => {\r\n        if (p.size > 0) {\r\n          ctx.beginPath();\r\n          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\r\n          ctx.fillStyle = `rgba(126, 34, 206, ${p.opacity})`;\r\n          ctx.fill();\r\n        }\r\n      });\r\n    }\r\n\r\n    function updateWhispers() {\r\n      const now = Date.now();\r\n      whispers.current = whispers.current.filter((w) => w.opacity > 0 || (now - w.createdAt) < 12000);\r\n      whispers.current.forEach((w) => {\r\n        const age = now - w.createdAt;\r\n        if (age < 5000) {\r\n          w.opacity = age / 5000; // Fade in over 5 seconds\r\n        } else if (age > 7000) {\r\n          w.opacity = Math.max(0, 0.2 - (age - 7000) / 5000); // Fade out after 7 seconds\r\n        } else {\r\n          w.opacity = 0.2; // Full opacity\r\n        }\r\n      });\r\n    }\r\n\r\n    function drawWhispers() {\r\n      ctx.font = 'bold 24px \"Orbitron\"';\r\n      ctx.textAlign = 'center';\r\n      whispers.current.forEach((w) => {\r\n        ctx.fillStyle = `rgba(0, 0, 0, ${w.opacity})`;\r\n        ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';\r\n        ctx.shadowOffsetX = 2;\r\n        ctx.shadowOffsetY = 2;\r\n        ctx.shadowBlur = 3;\r\n        ctx.fillText(w.text, w.x, w.y);\r\n        ctx.shadowColor = 'transparent';\r\n      });\r\n    }\r\n\r\n    function animate(time) {\r\n        ctx.clearRect(0, 0, width, height);\r\n        drawBackground();\r\n        drawOrb(time / 1000);\r\n        updateParticles();\r\n        drawParticles();\r\n        updateWhispers();\r\n        drawWhispers();\r\n      \r\n        if (isSplit && splitProgress < 1) {\r\n          setSplitProgress(prev => Math.min(prev + 0.005, 1)); // Even slower animation\r\n        } else if (!isSplit && splitProgress > 0) {\r\n          setSplitProgress(prev => Math.max(prev - 0.005, 0)); // Even slower animation\r\n        }\r\n      \r\n        requestAnimationFrame(animate);\r\n      }\r\n\r\n    function handleMouseMove(event) {\r\n      const x = event.clientX;\r\n      const y = event.clientY;\r\n\r\n      const dx = x - width / 2;\r\n      const dy = y - height / 2;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance < orbRadius) {\r\n        if (Math.random() < 0.02) {\r\n          whispers.current.push({\r\n            text: greetings[Math.floor(Math.random() * greetings.length)],\r\n            x: width / 2 + Math.random() * 200 - 100,\r\n            y: height / 2 + Math.random() * 200 - 100,\r\n            opacity: 0,\r\n            createdAt: Date.now(),\r\n          });\r\n        }\r\n      }\r\n\r\n      if (Math.random() < 0.3) {\r\n        const angle = Math.random() * 2 * Math.PI;\r\n        const speed = 0.5 + Math.random() * 1;\r\n        particles.current.push({\r\n          x,\r\n          y,\r\n          vx: Math.cos(angle) * speed,\r\n          vy: Math.sin(angle) * speed,\r\n          opacity: 0.5,\r\n          size: 1 + Math.random() * 2,\r\n        });\r\n      }\r\n    }\r\n\r\n    function handleClick(event) {\r\n      const x = event.clientX;\r\n      const y = event.clientY;\r\n      const dx = x - width / 2;\r\n      const dy = y - height / 2;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance < orbRadius) {\r\n        setIsSplit(prev => !prev);\r\n      }\r\n    }\r\n\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n    canvas.addEventListener('mousemove', handleMouseMove);\r\n    canvas.addEventListener('click', handleClick);\r\n\r\n    requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas);\r\n      canvas.removeEventListener('mousemove', handleMouseMove);\r\n      canvas.removeEventListener('click', handleClick);\r\n    };\r\n  }, [isSplit, splitProgress]);\r\n\r\n  return <canvas ref={canvasRef} style={{ width: '100%', height: '100%', display: 'block' }} />;\r\n};\r\n\r\nexport default EtherealOrb;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}